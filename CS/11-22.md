1. 쿠키와 세션의 차이에 대해 설명해 주세요.
- 쿠키는 클라이언트에 저장되는 데이터, 세션은 서버가 저장하는 데이터입니다.
쿠키는 조작·탈취 위험이 있고 사소한 정보에 적합하고,
세션은 서버가 상태를 관리하기 때문에 보안적이지만 서버 자원을 사용합니다.

2. 세션 방식의 로그인 과정에 대해 설명해 주세요.
- 사용자가 로그인하면 서버는 인증 후 사용자 정보를 세션 스토리지에 저장하고,
그 키인 세션 ID를 쿠키로 브라우저에 전달합니다.
브라우저는 이후 모든 요청에 세션 ID를 포함하고, 서버는 이를 조회해 로그인 상태를 확인합니다.

3. HTTP의 특성인 Stateless에 대해 설명해 주세요.
- Stateless란 서버가 요청 간의 상태를 기억하지 않는 특성입니다.
HTTP는 원래 로그인 상태 같은 걸 추적하지 않기 때문에,
이를 해결하기 위해 쿠키나 세션 같은 외부 상태 관리 방식이 필요합니다.

4. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
- 세션은 서버가 상태를 저장하기 때문에 Stateless 원칙에는 어긋납니다.
하지만 전통적인 웹 시스템에서는 구현이 단순하고 안전하기 때문에 많이 쓰이며,
대규모 분산 환경에서는 Redis 세션이나 JWT 기반 인증을 사용해 확장성을 확보합니다.

5. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
- 서버가 여러 대면 세션 일관성이 깨지므로 Sticky Session, 서버 간 세션 복제,
그리고 가장 일반적인 방식인 Redis 같은 외부 세션 저장소를 사용합니다.
실무에서는 확장성과 안정성을 위해 Redis 세션 스토어를 가장 많이 사용합니다.

6. HTTP 응답코드에 대해 설명해 주세요.
- HTTP 응답 코드는 요청 처리 결과를 의미하며 1xx~5xx로 구분됩니다.
2xx는 성공, 3xx는 리다이렉션, 4xx는 클라이언트 오류, 5xx는 서버 오류를 나타냅니다.

7. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
- 401은 사용자가 ‘인증되지 않은’ 상태이고,
403은 인증은 되었지만 해당 자원에 대한 ‘권한이 없는’ 상태입니다.

8. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.
- 200은 요청이 정상적으로 처리되었다는 일반적인 응답이고,
201은 요청으로 인해 새로운 자원이 생성된 경우 사용합니다.

9. 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.
- 기술적으로는 285 같은 응답코드를 보내는 것이 가능하지만,
표준을 벗어나면 브라우저·클라이언트·프록시가 정상적으로 처리하지 못해
실무에서는 절대 사용하지 않습니다.
대신 표준 HTTP 코드 + 내부 에러코드를 JSON 바디로 전달합니다.

10. HTTP Method 에 대해 설명해 주세요.
- HTTP 메서드는 클라이언트가 서버의 특정 리소스에 대해 어떤 동작을 수행하고 싶은지 그 의도를 정의하는 명령어입니다. 이는 주로 CRUD 작업에 매핑되어 사용되며, 핵심 메서드로는 GET (조회), POST (생성), PUT (전체 수정), PATCH (부분 수정), 그리고 DELETE (제거)가 있습니다. 이 메서드들을 통해 클라이언트와 서버 간의 상호작용을 명확하게 정의할 수 있습니다.

11. HTTP Method의 멱등성에 대해 설명해 주세요.
- 멱등성이란 클라이언트가 동일한 요청을 서버에 여러 번 전송해도, 서버의 리소스 상태가 결과적으로는 동일하게 유지되는 성질을 말합니다. 요청 횟수가 서버 상태의 최종 결과에 영향을 주지 않아야 하죠.
예를 들어, GET은 조회만 하므로 당연히 멱등적이고, PUT은 리소스를 클라이언트가 보낸 데이터로 완전히 교체하기 때문에 여러 번 요청해도 최종 상태는 같습니다. 반면에 POST는 매번 새로운 리소스를 생성하기 때문에 요청 횟수만큼 리소스가 늘어나 비멱등적입니다. 멱등성은 네트워크 오류 등으로 요청이 중복될 때 시스템 안정성을 확보하는 중요한 기준입니다.

12. GET과 POST의 차이는 무엇인가요?
- GET과 POST는 HTTP 통신의 가장 기본이 되며, 목적과 기술적 특성에서 큰 차이를 보입니다.
GET은 리소스 조회가 주 목적이고, 서버의 상태를 변경하지 않기에 안전(Safe)하고 멱등적입니다. 데이터는 URL의 쿼리 파라미터에 담겨 전송되므로 노출되고 길이 제한이 있습니다.
반면 POST는 새로운 리소스 생성이나 서버에 데이터를 처리하는 것이 주 목적입니다. 서버의 상태를 변경하여 안전하지 않고, 호출할 때마다 리소스가 늘어나 비멱등적입니다. 데이터는 HTTP 메시지 Body에 담아 전송되기에 대용량 전송이 가능하고 보안에 유리합니다.

13. POST와 PUT, PATCH의 차이는 무엇인가요?
- POST, PUT, PATCH는 데이터를 서버로 전송하지만, 리소스에 대한 행위의 범위와 목적이 다릅니다.
POST는 주로 새로운 리소스를 생성하는 것이 목적이며, 매번 새로운 리소스를 만들기에 비멱등적입니다.
PUT은 클라이언트가 명시한 URI의 리소스를 클라이언트가 보낸 데이터로 완전히 덮어써서 교체하는 방식입니다. 전체 리소스를 교체하므로 여러 번 요청해도 최종 상태가 같아 멱등적입니다.
PATCH는 리소스의 일부 필드만을 선택적으로 수정할 때 사용됩니다. 전체를 교체하는 PUT과 달리 변경할 필드만 전송하며, 일반적으로 상태를 반복적으로 변경할 수 있어 비멱등적으로 간주됩니다. 따라서 부분 업데이트에는 PATCH를 사용하는 것이 RESTful 설계에 가장 적합합니다.

14. HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
- 기술적으로 말씀드리자면, HTTP 명세 자체는 GET 요청의 Body 사용을 명시적으로 금지하고 있지는 않습니다. 하지만 실제 현업에서는 이 방식을 철저하게 지양하고 있습니다. 이유는 크게 두 가지입니다.
첫째, 의미론적인 충돌입니다. GET의 본질적인 역할은 리소스를 **조회(Read)**하는 것이고, Body는 데이터 전송의 의미가 강합니다. HTTP의 기본 원칙인 표준화된 의미론을 지키기 위해 GET은 쿼리 파라미터만 사용하고 Body는 사용하지 않는 것이 원칙입니다.
둘째, 실제 시스템의 호환성 문제입니다. 대다수의 프록시 서버, 캐시 서버, 그리고 로드 밸런서 구현체들이 GET 요청에 Body가 포함되면 이를 무시하거나, 예상치 못한 동작을 하도록 설계되어 있습니다. 만약 Body를 사용한다면 시스템 간에 호환성 문제가 발생하여 장애로 이어질 수 있습니다.
따라서 Body에 데이터를 실어 조회하려면 RESTful 원칙에 더 부합하는 POST 메서드를 사용하되, 서버에서 조회(Read) 목적으로만 처리하고 멱등성을 보장하도록 구현하는 것이 일반적인 안전한 방식입니다

15. HTTP에 대해 설명해 주세요.
- HTTP, 즉 하이퍼텍스트 전송 프로토콜은 웹상에서 데이터를 주고받는 데 사용되는 가장 기본적인 통신 규약입니다.
가장 중요한 특징은 클라이언트-서버 모델을 따른다는 점입니다. 클라이언트가 요청을 보내면 서버가 그에 대한 응답을 반환하는 구조죠. 또 하나의 핵심 특징은 Stateless(무상태성)입니다. 서버는 클라이언트와의 이전 요청 상태를 기억하지 않습니다. 이 덕분에 서버 부하가 줄고 확장성이 높아지지만, 사용자 세션 관리가 필요할 경우 쿠키나 세션 같은 별도의 기술을 사용해야 합니다.
HTTP는 TCP/IP 위에서 동작하며, 저희가 흔히 웹 브라우저를 통해 서버와 통신하는 모든 과정의 기본이 되는 프로토콜이라고 이해하시면 됩니다.

16. 공개키와 대칭키에 대해 설명해 주세요.
- 암호화 방식은 크게 대칭키와 공개키(비대칭키) 두 가지로 나뉩니다.
먼저 대칭키 방식은 데이터를 암호화하고 복호화할 때 완전히 동일한 키를 사용하는 방식입니다. 처리 속도가 굉장히 빠르다는 장점이 있지만, 통신을 시작하기 전에 이 키를 주고받는 과정, 즉 키 분배를 안전하게 하는 것이 가장 큰 숙제이자 단점입니다.
반면에 공개키 방식은 공개키와 개인키가 한 쌍으로 존재합니다. 공개키는 누구나 가질 수 있고 암호화에 쓰이며, 개인키는 오직 키의 소유자만 복호화에 사용합니다. 이 방식은 키를 안전하게 교환할 수 있다는 장점이 있지만, 대칭키 방식보다 연산 속도가 훨씬 느리다는 단점이 있습니다.
실제 시스템, 특히 HTTPS에서는 이 두 방식의 장점만을 취합하여 사용합니다.

17. 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
- HTTPS Handshake 과정에서 인증서를 사용하는 핵심적인 목적은 서버의 신원을 클라이언트가 확실하게 검증하기 위함입니다.
저희가 웹에서 통신할 때, 중간자 공격자가 '나는 구글이야'라고 속일 수 있거든요. 이때 서버는 자신이 진짜 서버라는 것을 증명하기 위해 신뢰할 수 있는 제3자, 즉 **인증 기관(CA)**이 발급한 인증서를 클라이언트에게 제시합니다.
클라이언트는 이 인증서에 담긴 CA의 서명을 검증하여, 이 서버가 사칭이 아닌 CA에게 공식적으로 등록된 서버임을 확인합니다. 이 검증 과정을 거쳐야만 클라이언트는 인증서 안에 들어있는 서버의 공개키를 신뢰하고, 안전하게 암호화 통신을 시작할 수 있는 기반이 마련됩니다.

18. SSL과 TLS의 차이는 무엇인가요?
- 기술적으로는 SSL과 TLS는 버전의 차이, 즉 후속 기술입니다.
SSL (Secure Sockets Layer)은 넷스케이프에서 개발한 초기 보안 프로토콜의 이름입니다. 하지만 여러 보안 취약점이 발견되면서 이를 보완하고 표준화하는 과정이 필요해졌습니다.
그 결과, SSL 3.0의 후속으로 **TLS (Transport Layer Security)**라는 이름으로 새롭게 명명되고 국제 표준으로 자리 잡았습니다. 현재 저희가 HTTPS 통신에서 사용하고 있는 모든 보안 프로토콜은 사실상 TLS 1.2 또는 1.3 버전입니다.
요약하자면, TLS가 SSL의 최신 버전이자 공식 명칭이며, SSL은 관용적으로 사용하는 구 명칭이라고 이해하시면 됩니다.

19. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
- 소켓은 TCP/UDP 통신을 위한 일반적인 인터페이스이고, 웹소켓은 HTTP Upgrade 이후 TCP 기반으로 브라우저와 서버가 지속적으로 양방향 통신할 수 있게 만든 프로토콜입니다.
브라우저 환경에서는 Raw TCP를 사용할 수 없기 때문에 웹소켓을 사용합니다.

20. 소켓과 포트의 차이가 무엇인가요?
- 포트는 하나의 IP 안에서 여러 서비스(HTTP 80, HTTPS 443 등)를 구분하기 위한 번호이고,
소켓은 'IP + Port + 프로토콜(TCP/UDP)'로 구성된 통신 엔드포인트입니다.

21. 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
- 서버는 같은 포트(예: 80)에 바인딩된 하나의 소켓만 사용합니다.
하지만 새로운 클라이언트가 접속할 때마다 서버는 새로운 커넥션 소켓(FD)을 생성하며,
이때 클라이언트의 포트는 매번 다른 동적 포트가 부여됩니다.
즉 ‘서버 포트는 같고’, ‘클라이언트 포트는 다릅니다.

22. 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
- 연결이 많아지면 커넥션 소켓(FD)이 많이 생성됩니다.
하지만 요청이 아니라 ‘연결’당 하나이므로, HTTP/1.1 keep-alive나 HTTP/2처럼 한 연결에서 여러 요청을 처리하면 FD가 폭발적으로 늘어나진 않습니다.
많은 연결도 epoll 같은 I/O 멀티플렉싱으로 효율적으로 처리합니다

23. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
- HTTP/1.1은 하나의 연결에서 하나의 요청만 처리할 수 있어서 병렬 요청 시 여러 TCP 연결이 필요했습니다.
HTTP/2는 하나의 TCP 연결에서 여러 스트림을 동시에 처리할 수 있는 다중화(Multiplexing) 기능을 제공하고,
HPACK 기반 헤더 압축 및 서버 푸시를 지원해 성능과 효율이 크게 향상되었습니다.

24. HOL Blocking 에 대해 설명해 주세요.
- HOL Blocking은 앞선 요청이나 패킷이 지연되면 뒤에 있는 요청들도 연쇄적으로 지연되는 현상입니다.
HTTP/1.1에선 파이프라이닝으로 발생했고, HTTP/2도 TCP 기반이기 때문에 패킷 손실이 일어나면 여러 스트림이 동시에 영향을 받아 HOL 문제가 남아 있습니다.

25. HTTP/3.0의 주요 특징에 대해 설명해 주세요.
- HTTP/3는 TCP 대신 QUIC(UDP 기반 전송계층) 을 사용합니다.
QUIC은 스트림 단위 전송이 독립적이기 때문에 TCP에서 발생하던 HOL Blocking이 사라지고,
TLS 1.3이 기본 내장돼 있어 보안 설정과 핸드셰이크 속도도 빠릅니다.
패킷 손실이 있어도 다른 스트림에 영향을 주지 않아 지연이 크게 줄어드는 것이 핵심 특징입니다.
