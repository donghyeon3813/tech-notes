1. 쿠키와 세션의 차이에 대해 설명해 주세요.
- 쿠키는 클라이언트에 저장되는 데이터, 세션은 서버가 저장하는 데이터입니다.
쿠키는 조작·탈취 위험이 있고 사소한 정보에 적합하고,
세션은 서버가 상태를 관리하기 때문에 보안적이지만 서버 자원을 사용합니다.

2. 세션 방식의 로그인 과정에 대해 설명해 주세요.
- 사용자가 로그인하면 서버는 인증 후 사용자 정보를 세션 스토리지에 저장하고,
그 키인 세션 ID를 쿠키로 브라우저에 전달합니다.
브라우저는 이후 모든 요청에 세션 ID를 포함하고, 서버는 이를 조회해 로그인 상태를 확인합니다.

3. HTTP의 특성인 Stateless에 대해 설명해 주세요.
- Stateless란 서버가 요청 간의 상태를 기억하지 않는 특성입니다.
HTTP는 원래 로그인 상태 같은 걸 추적하지 않기 때문에,
이를 해결하기 위해 쿠키나 세션 같은 외부 상태 관리 방식이 필요합니다.

4. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
- 세션은 서버가 상태를 저장하기 때문에 Stateless 원칙에는 어긋납니다.
하지만 전통적인 웹 시스템에서는 구현이 단순하고 안전하기 때문에 많이 쓰이며,
대규모 분산 환경에서는 Redis 세션이나 JWT 기반 인증을 사용해 확장성을 확보합니다.

5. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
- 서버가 여러 대면 세션 일관성이 깨지므로 Sticky Session, 서버 간 세션 복제,
그리고 가장 일반적인 방식인 Redis 같은 외부 세션 저장소를 사용합니다.
실무에서는 확장성과 안정성을 위해 Redis 세션 스토어를 가장 많이 사용합니다.

6. HTTP 응답코드에 대해 설명해 주세요.
- HTTP 응답 코드는 요청 처리 결과를 의미하며 1xx~5xx로 구분됩니다.
2xx는 성공, 3xx는 리다이렉션, 4xx는 클라이언트 오류, 5xx는 서버 오류를 나타냅니다.

7. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
- 401은 사용자가 ‘인증되지 않은’ 상태이고,
403은 인증은 되었지만 해당 자원에 대한 ‘권한이 없는’ 상태입니다.

8. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.
- 200은 요청이 정상적으로 처리되었다는 일반적인 응답이고,
201은 요청으로 인해 새로운 자원이 생성된 경우 사용합니다.

9. 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.
- 기술적으로는 285 같은 응답코드를 보내는 것이 가능하지만,
표준을 벗어나면 브라우저·클라이언트·프록시가 정상적으로 처리하지 못해
실무에서는 절대 사용하지 않습니다.
대신 표준 HTTP 코드 + 내부 에러코드를 JSON 바디로 전달합니다.

10. HTTP Method 에 대해 설명해 주세요.
- HTTP 메서드는 클라이언트가 서버의 특정 리소스에 대해 어떤 동작을 수행하고 싶은지 그 의도를 정의하는 명령어입니다. 이는 주로 CRUD 작업에 매핑되어 사용되며, 핵심 메서드로는 GET (조회), POST (생성), PUT (전체 수정), PATCH (부분 수정), 그리고 DELETE (제거)가 있습니다. 이 메서드들을 통해 클라이언트와 서버 간의 상호작용을 명확하게 정의할 수 있습니다.

11. HTTP Method의 멱등성에 대해 설명해 주세요.
- 멱등성이란 클라이언트가 동일한 요청을 서버에 여러 번 전송해도, 서버의 리소스 상태가 결과적으로는 동일하게 유지되는 성질을 말합니다. 요청 횟수가 서버 상태의 최종 결과에 영향을 주지 않아야 하죠.
예를 들어, GET은 조회만 하므로 당연히 멱등적이고, PUT은 리소스를 클라이언트가 보낸 데이터로 완전히 교체하기 때문에 여러 번 요청해도 최종 상태는 같습니다. 반면에 POST는 매번 새로운 리소스를 생성하기 때문에 요청 횟수만큼 리소스가 늘어나 비멱등적입니다. 멱등성은 네트워크 오류 등으로 요청이 중복될 때 시스템 안정성을 확보하는 중요한 기준입니다.

12. GET과 POST의 차이는 무엇인가요?
- GET과 POST는 HTTP 통신의 가장 기본이 되며, 목적과 기술적 특성에서 큰 차이를 보입니다.
GET은 리소스 조회가 주 목적이고, 서버의 상태를 변경하지 않기에 안전(Safe)하고 멱등적입니다. 데이터는 URL의 쿼리 파라미터에 담겨 전송되므로 노출되고 길이 제한이 있습니다.
반면 POST는 새로운 리소스 생성이나 서버에 데이터를 처리하는 것이 주 목적입니다. 서버의 상태를 변경하여 안전하지 않고, 호출할 때마다 리소스가 늘어나 비멱등적입니다. 데이터는 HTTP 메시지 Body에 담아 전송되기에 대용량 전송이 가능하고 보안에 유리합니다.

13. POST와 PUT, PATCH의 차이는 무엇인가요?
- POST, PUT, PATCH는 데이터를 서버로 전송하지만, 리소스에 대한 행위의 범위와 목적이 다릅니다.
POST는 주로 새로운 리소스를 생성하는 것이 목적이며, 매번 새로운 리소스를 만들기에 비멱등적입니다.
PUT은 클라이언트가 명시한 URI의 리소스를 클라이언트가 보낸 데이터로 완전히 덮어써서 교체하는 방식입니다. 전체 리소스를 교체하므로 여러 번 요청해도 최종 상태가 같아 멱등적입니다.
PATCH는 리소스의 일부 필드만을 선택적으로 수정할 때 사용됩니다. 전체를 교체하는 PUT과 달리 변경할 필드만 전송하며, 일반적으로 상태를 반복적으로 변경할 수 있어 비멱등적으로 간주됩니다. 따라서 부분 업데이트에는 PATCH를 사용하는 것이 RESTful 설계에 가장 적합합니다.

14. HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
- 기술적으로 말씀드리자면, HTTP 명세 자체는 GET 요청의 Body 사용을 명시적으로 금지하고 있지는 않습니다. 하지만 실제 현업에서는 이 방식을 철저하게 지양하고 있습니다. 이유는 크게 두 가지입니다.
첫째, 의미론적인 충돌입니다. GET의 본질적인 역할은 리소스를 **조회(Read)**하는 것이고, Body는 데이터 전송의 의미가 강합니다. HTTP의 기본 원칙인 표준화된 의미론을 지키기 위해 GET은 쿼리 파라미터만 사용하고 Body는 사용하지 않는 것이 원칙입니다.
둘째, 실제 시스템의 호환성 문제입니다. 대다수의 프록시 서버, 캐시 서버, 그리고 로드 밸런서 구현체들이 GET 요청에 Body가 포함되면 이를 무시하거나, 예상치 못한 동작을 하도록 설계되어 있습니다. 만약 Body를 사용한다면 시스템 간에 호환성 문제가 발생하여 장애로 이어질 수 있습니다.
따라서 Body에 데이터를 실어 조회하려면 RESTful 원칙에 더 부합하는 POST 메서드를 사용하되, 서버에서 조회(Read) 목적으로만 처리하고 멱등성을 보장하도록 구현하는 것이 일반적인 안전한 방식입니다

15. HTTP에 대해 설명해 주세요.
- HTTP, 즉 하이퍼텍스트 전송 프로토콜은 웹상에서 데이터를 주고받는 데 사용되는 가장 기본적인 통신 규약입니다.
가장 중요한 특징은 클라이언트-서버 모델을 따른다는 점입니다. 클라이언트가 요청을 보내면 서버가 그에 대한 응답을 반환하는 구조죠. 또 하나의 핵심 특징은 Stateless(무상태성)입니다. 서버는 클라이언트와의 이전 요청 상태를 기억하지 않습니다. 이 덕분에 서버 부하가 줄고 확장성이 높아지지만, 사용자 세션 관리가 필요할 경우 쿠키나 세션 같은 별도의 기술을 사용해야 합니다.
HTTP는 TCP/IP 위에서 동작하며, 저희가 흔히 웹 브라우저를 통해 서버와 통신하는 모든 과정의 기본이 되는 프로토콜이라고 이해하시면 됩니다.

16. 공개키와 대칭키에 대해 설명해 주세요.
- 암호화 방식은 크게 대칭키와 공개키(비대칭키) 두 가지로 나뉩니다.
먼저 대칭키 방식은 데이터를 암호화하고 복호화할 때 완전히 동일한 키를 사용하는 방식입니다. 처리 속도가 굉장히 빠르다는 장점이 있지만, 통신을 시작하기 전에 이 키를 주고받는 과정, 즉 키 분배를 안전하게 하는 것이 가장 큰 숙제이자 단점입니다.
반면에 공개키 방식은 공개키와 개인키가 한 쌍으로 존재합니다. 공개키는 누구나 가질 수 있고 암호화에 쓰이며, 개인키는 오직 키의 소유자만 복호화에 사용합니다. 이 방식은 키를 안전하게 교환할 수 있다는 장점이 있지만, 대칭키 방식보다 연산 속도가 훨씬 느리다는 단점이 있습니다.
실제 시스템, 특히 HTTPS에서는 이 두 방식의 장점만을 취합하여 사용합니다.

17. 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
- HTTPS Handshake 과정에서 인증서를 사용하는 핵심적인 목적은 서버의 신원을 클라이언트가 확실하게 검증하기 위함입니다.
저희가 웹에서 통신할 때, 중간자 공격자가 '나는 구글이야'라고 속일 수 있거든요. 이때 서버는 자신이 진짜 서버라는 것을 증명하기 위해 신뢰할 수 있는 제3자, 즉 **인증 기관(CA)**이 발급한 인증서를 클라이언트에게 제시합니다.
클라이언트는 이 인증서에 담긴 CA의 서명을 검증하여, 이 서버가 사칭이 아닌 CA에게 공식적으로 등록된 서버임을 확인합니다. 이 검증 과정을 거쳐야만 클라이언트는 인증서 안에 들어있는 서버의 공개키를 신뢰하고, 안전하게 암호화 통신을 시작할 수 있는 기반이 마련됩니다.

18. SSL과 TLS의 차이는 무엇인가요?
- 기술적으로는 SSL과 TLS는 버전의 차이, 즉 후속 기술입니다.
SSL (Secure Sockets Layer)은 넷스케이프에서 개발한 초기 보안 프로토콜의 이름입니다. 하지만 여러 보안 취약점이 발견되면서 이를 보완하고 표준화하는 과정이 필요해졌습니다.
그 결과, SSL 3.0의 후속으로 **TLS (Transport Layer Security)**라는 이름으로 새롭게 명명되고 국제 표준으로 자리 잡았습니다. 현재 저희가 HTTPS 통신에서 사용하고 있는 모든 보안 프로토콜은 사실상 TLS 1.2 또는 1.3 버전입니다.
요약하자면, TLS가 SSL의 최신 버전이자 공식 명칭이며, SSL은 관용적으로 사용하는 구 명칭이라고 이해하시면 됩니다.

19. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
- 소켓은 TCP/UDP 통신을 위한 일반적인 인터페이스이고, 웹소켓은 HTTP Upgrade 이후 TCP 기반으로 브라우저와 서버가 지속적으로 양방향 통신할 수 있게 만든 프로토콜입니다.
브라우저 환경에서는 Raw TCP를 사용할 수 없기 때문에 웹소켓을 사용합니다.

20. 소켓과 포트의 차이가 무엇인가요?
- 포트는 하나의 IP 안에서 여러 서비스(HTTP 80, HTTPS 443 등)를 구분하기 위한 번호이고,
소켓은 'IP + Port + 프로토콜(TCP/UDP)'로 구성된 통신 엔드포인트입니다.

21. 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
- 서버는 같은 포트(예: 80)에 바인딩된 하나의 소켓만 사용합니다.
하지만 새로운 클라이언트가 접속할 때마다 서버는 새로운 커넥션 소켓(FD)을 생성하며,
이때 클라이언트의 포트는 매번 다른 동적 포트가 부여됩니다.
즉 ‘서버 포트는 같고’, ‘클라이언트 포트는 다릅니다.

22. 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
- 연결이 많아지면 커넥션 소켓(FD)이 많이 생성됩니다.
하지만 요청이 아니라 ‘연결’당 하나이므로, HTTP/1.1 keep-alive나 HTTP/2처럼 한 연결에서 여러 요청을 처리하면 FD가 폭발적으로 늘어나진 않습니다.
많은 연결도 epoll 같은 I/O 멀티플렉싱으로 효율적으로 처리합니다

23. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
- HTTP/1.1은 하나의 연결에서 하나의 요청만 처리할 수 있어서 병렬 요청 시 여러 TCP 연결이 필요했습니다.
HTTP/2는 하나의 TCP 연결에서 여러 스트림을 동시에 처리할 수 있는 다중화(Multiplexing) 기능을 제공하고,
HPACK 기반 헤더 압축 및 서버 푸시를 지원해 성능과 효율이 크게 향상되었습니다.

24. HOL Blocking 에 대해 설명해 주세요.
- HOL Blocking은 앞선 요청이나 패킷이 지연되면 뒤에 있는 요청들도 연쇄적으로 지연되는 현상입니다.
HTTP/1.1에선 파이프라이닝으로 발생했고, HTTP/2도 TCP 기반이기 때문에 패킷 손실이 일어나면 여러 스트림이 동시에 영향을 받아 HOL 문제가 남아 있습니다.

25. HTTP/3.0의 주요 특징에 대해 설명해 주세요.
- HTTP/3는 TCP 대신 QUIC(UDP 기반 전송계층) 을 사용합니다.
QUIC은 스트림 단위 전송이 독립적이기 때문에 TCP에서 발생하던 HOL Blocking이 사라지고,
TLS 1.3이 기본 내장돼 있어 보안 설정과 핸드셰이크 속도도 빠릅니다.
패킷 손실이 있어도 다른 스트림에 영향을 주지 않아 지연이 크게 줄어드는 것이 핵심 특징입니다.

26. TCP와 UDP의 차이에 대해 설명해 주세요.
- TCP는 연결형 프로토콜로 신뢰성을 보장하기 위해
재전송, 순서 보장, 흐름·혼잡 제어를 지원합니다.
UDP는 비연결형으로 신뢰적인 기능이 없지만 오버헤드가 적고 빠르기 때문에
스트리밍, 게임 등 실시간성이 중요한 분야에 사용됩니다.

27.Checksum이 무엇인가요?
- Checksum은 전송된 데이터가 중간에서 손상되었는지 확인하기 위한
오류 검출 메커니즘입니다. 송신과 수신 측이 동일한 계산을 수행해
일치 여부로 오류 발생을 판단합니다.

28.TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
- TCP와 UDP는 모두 Checksum을 사용합니다.
TCP는 의무이며, UDP는 IPv6에서는 필수, IPv4에서는 선택적입니다.

29.그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
- 아니요. Checksum은 오류를 검출만 할 수 있고 정정은 할 수 없습니다.
TCP는 오류 발생 시 재전송으로 보완하며, UDP는 애플리케이션에서 직접 처리해야 합니다.

30.TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
- TCP는 먼저 3-way handshake로 안정적인 연결을 맺고, 각 데이터에 시퀀스 번호와 ACK를 사용해 순서와 손실 여부를 관리합니다. 전송 중 데이터가 손상되면 체크섬으로 오류를 검출하고 필요하면 자동으로 재전송합니다. 또한 흐름 제어로 수신 측의 처리 속도에 맞춰 전송량을 조절하고, 혼잡 제어를 통해 네트워크 상황에 따라 전송 속도를 조절함으로써 전체적인 신뢰성을 확보합니다.

31. TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
- TCP는 네트워크에 혼잡이 발생하지 않도록 전송량을 동적으로 조절하는 혼잡 제어를 수행합니다. 처음에는 Slow Start로 전송량을 빠르게 증가시키다가, 임계점에 도달하면 Congestion Avoidance로 완만하게 증가시키며 네트워크 상태를 안정적으로 유지합니다. 패킷 손실이 감지되면 Fast Retransmit을 통해 즉시 재전송하고, Fast Recovery로 전송량을 적절히 복구해 네트워크 붕괴를 방지합니다.

32. 왜 HTTP는 TCP를 사용하나요?
- HTTP는 텍스트 기반 정보가 손실 없이 정확하게 전달되어야 하므로 순서 보장, 재전송, 흐름·혼잡 제어 같은 신뢰성 기능을 가진 TCP가 적합합니다. HTTP의 특성상 빠른 속도보다 정확성이 우선이기 때문입니다.

33. 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
- HTTP/3는 QUIC 프로토콜을 사용하며, 이는 UDP 위에서 TCP의 신뢰성 기능을 직접 구현합니다. 덕분에 TCP에서 발생하던 HOL Blocking 문제를 해결하고 더 빠른 연결 수립과 스트림 단위의 독립적인 전송이 가능합니다. 즉, UDP의 “문제가 해결되었다”기보다 UDP 위에서 TCP보다 더 효율적인 방식으로 신뢰성을 다시 구현한 것이라고 보는 게 정확합니다.

34. 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
- 브라우저는 서버의 응답에 포함된 Alt-Svc 헤더를 통해 해당 서버가 HTTP/3(UDP 기반)을 지원하는지 확인합니다. 지원하면 UDP 443으로 QUIC 연결을 시도하고, 실패하거나 미지원이면 자동으로 TCP 기반 HTTP/2/1.1로 fallback합니다.

35. 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
- 프로토콜을 설계할 때 “신뢰성 vs 속도”를 기준으로 선택합니다.
데이터가 손실 없이 정확해야 하고 순서가 중요한 경우라면 TCP가 적합하고, 지연이 적은 전송이 더 중요하고 약간의 손실이 허용되는 실시간 통신이라면 UDP를 선택해 필요한 신뢰성 기능을 애플리케이션에서 직접 구현하겠습니다.

36. DHCP가 무엇인지 설명해 주세요.
- DHCP는 네트워크에 접속한 장비에게 IP 주소와 네트워크 설정 정보를 자동으로 할당해주는 프로토콜입니다. 별도의 수동 설정 없이 네트워크 환경을 구성할 수 있도록 도와줍니다.

37. DHCP는 몇 계층 프로토콜인가요?
- DHCP는 OSI 7계층 중 애플리케이션 계층에서 동작하는 프로토콜입니다.

38. DHCP는 어떻게 동작하나요?
- DHCP는 Discover, Offer, Request, Acknowledgment의 4단계를 거쳐 IP를 자동으로 할당합니다. 클라이언트가 서버를 찾고, 서버가 IP를 제안하며, 클라이언트가 선택하고, 서버가 최종 승인하는 구조입니다.

39. DHCP에서 UDP를 사용하는 이유가 무엇인가요?
- DHCP는 IP가 없는 장비와 통신해야 하기 때문에 연결을 요구하는 TCP를 사용할 수 없습니다. 또한 브로드캐스트 기반으로 서버를 찾아야 하므로 브로드캐스트가 가능한 UDP가 적합하며, 패킷이 유실되면 재시도하면 되기 때문에 UDP의 단순함이 장점입니다.

40. DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?
- 네, DHCP는 IP 주소뿐 아니라 서브넷 마스크, 게이트웨이, DNS 서버, NTP 서버 등 네트워크 설정에 필요한 다양한 정보를 함께 제공합니다.

41. DHCP의 유효기간은 얼마나 긴가요?
- DHCP의 유효기간은 DHCP 서버에서 설정한 임대 시간(Lease Time)에 따라 달라지며 몇 분에서 몇 주까지 다양하게 설정할 수 있습니다. 일반적으로는 24시간이 기본 값이며, 임대 기간의 절반이 지나면 클라이언트가 자동으로 갱신을 요청합니다.

42. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?
- IP 주소는 네트워크에서 기기를 식별하기 위한 논리적 주소입니다.
패킷은 출발지와 목적지 IP 주소를 포함해 전송되며, 라우터는 이 주소를 기반으로 올바른 경로로 패킷을 전달합니다.
즉, IP 주소는 “기기 식별”과 “패킷 전달”의 핵심 역할을 합니다.

43. IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?
- IPv6는 IPv4의 주소 고갈을 해결하기 위해 등장했지만, 실제 환경에서는 NAT와 사설 IP 덕분에 IPv4 주소 부족 문제가 크게 완화되었습니다.
가정과 회사는 공인 IP 하나를 공유하면서 수많은 장치가 사설 IP로 동작하기 때문에 IPv4 수요가 줄었습니다.
ISP는 CGN까지 사용해 공인 주소를 더욱 절약하고 있습니다.
IPv6 전환은 장비 교체 비용과 호환성 문제 때문에 시간이 오래 걸려 여전히 IPv4 중심 환경이 유지됩니다.

44. IPv4와 IPv6의 차이에 대해 설명해 주세요.
- IPv4는 32비트 주소로 약 43억 개의 주소만 제공하지만, IPv6는 128비트 구조로 사실상 무한 수준의 주소를 제공합니다.
IPv6는 NAT 없이 모든 장치가 공인 IP를 가질 수 있고, SLAAC 같은 자동 주소 설정 기능과 IPSec 기본 탑재 등 네트워크 관리와 보안 측면이 강화되어 있습니다.
두 주소 체계는 직접 호환되지 않아 전환 과정에서 이중 스택, 터널링 기술이 필요하다는 점도 중요한 차이입니다.

45. 수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?
- ISP가 제공하는 공인 IP는 유동 IP지만, 공유기 내부에서는 자체적으로 DHCP 서버가 동작하여 각 기기에 사설 IP를 배포합니다.
이때 공유기는 특정 MAC 주소를 가진 기기에게 항상 동일한 사설 IP를 주는 DHCP Reservation 기능을 제공하기 때문에 내부 네트워크에서는 “고정 IP”가 가능합니다.
즉, 외부 IP는 유동이어도, 내부 네트워크에서는 공유기가 직접 주소를 관리하기 때문에 고정 사설 IP를 제공할 수 있습니다.

46. IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
- IPv4와 IPv6는 직접 호환되지 않기 때문에 기본적으로는 바로 통신할 수 없습니다.
같은 네트워크에서 통신하려면 장치나 네트워크가 Dual Stack 환경을 구성해 두 프로토콜을 모두 지원해야 합니다.
또한 서로 다른 주소 체계를 사용하는 장치 간 통신은 터널링(6to4, Teredo) 또는 NAT64/DNS64 같은 변환 기술을 이용해 가능합니다.

47. IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
- IP는 비연결형 프로토콜로, 패킷의 전달 성공 여부나 순서, 무결성을 보장하지 않습니다.
IP는 단지 “최선을 다해(besteffort)” 패킷을 전달하는 역할만 하며, 신뢰성 보장은 TCP 같은 상위 프로토콜이 담당합니다.

48. IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
- IPv4의 Checksum은 IP 헤더만 검증해 오류를 매우 제한적으로만 확인할 수 있습니다.
반면 TCP의 Checksum은 TCP 헤더와 데이터 전체, 그리고 송수신 IP를 포함한 Pseudo Header까지 검사해 더 강력한 무결성 검증을 제공합니다.

49. TTL(Hop Limit)이란 무엇인가요?
- TTL은 패킷이 네트워크에서 무한히 순환하는 것을 방지하기 위해 라우터를 지날 때마다 감소하는 값입니다.
0이 되면 패킷은 폐기되며, IPv6에서는 같은 개념을 Hop Limit이라고 부릅니다.

50. IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.
- MAC 주소는 네트워크 카드에 할당된 고유한 물리적 주소로, 같은 LAN 내부에서 프레임을 전달할 때 사용됩니다.
IP 주소는 네트워크 상에서 변경 가능한 논리적 주소로, 라우터가 이 주소를 기준으로 패킷의 최종 목적지를 결정합니다.
즉, MAC은 로컬 식별자이고 IP는 전 세계 네트워크에서의 식별자입니다.

51. OSI 7계층에 대해 설명해 주세요.
- OSI 7계층은 네트워크 통신을 7단계로 구조화한 모델로, 물리 신호 전송부터 애플리케이션 통신까지의 전체 과정을 구분합니다.
1~3계층은 네트워크 전달, 4계층은 전송 신뢰성, 5~7계층은 사용자 서비스 제공이라는 역할을 나눕니다.
52. Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.
- Network Layer는 목적지까지의 경로를 결정하고 IP 기반으로 패킷을 전달하는 역할을 합니다.
Transport Layer는 도착지에서 어떤 프로세스로 전달할지 결정하며(TCP/UDP 포트), 필요한 경우 신뢰성을 제공합니다.
즉, 3계층은 “어디까지”, 4계층은 “누구에게” 전달하는 역할입니다.

53. L3 Switch와 Router의 차이에 대해 설명해 주세요.
- L3 스위치는 LAN 내부에서 빠른 라우팅을 수행하기 위한 장비이고, 라우터는 서로 다른 네트워크를 연결하거나 WAN 구간을 담당합니다.
L3 스위치는 속도 중심, 라우터는 기능 중심이라고 정리할 수 있습니다.
54. 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
- OSI 계층은 데이터를 PDU라고 부르며, 4계층은 Segment/Datagram, 3계층은 Packet, 2계층은 Frame, 1계층은 Bit로 구분됩니다.
55. 각각의 Header의 Packing Order에 대해 설명해 주세요.
- 데이터는 상위 계층 헤더가 안쪽에 위치하고, 하위 계층으로 내려갈수록 바깥쪽에 새 헤더가 붙습니다.
예를 들어 TCP 통신에서는 MAC → IP → TCP → Data 순으로 헤더가 감싸지며, 이를 캡슐화라고 합니다.
56. ARP에 대해 설명해 주세요.
- ARP는 IP 주소를 기반으로 MAC 주소를 알아내기 위한 프로토콜로, LAN에서 프레임을 전달하기 위해 필요합니다.
브로드캐스트로 요청하고, 응답을 받은 MAC-IP 매핑을 ARP 테이블에 저장해 이후 빠르게 통신할 수 있습니다.
