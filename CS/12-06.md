1. 3-Way Handshake에 대해 설명해 주세요.
- TCP는 신뢰성 있는 연결을 만들기 위해 3-Way Handshake를 이용합니다.
1단계에서 클라이언트가 SYN을 보내고, 2단계에서 서버는 SYN+ACK로 응답하며, 3단계에서 클라이언트가 ACK를 보내 연결이 수립됩니다.
이 과정을 통해 양쪽은 서로의 초기 시퀀스 번호를 공유하고, 데이터 전송 준비가 되었음을 확인합니다.

2. ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
- SYN, ACK 같은 정보는 TCP 헤더의 플래그 필드에서 비트 형태로 전달됩니다.
TCP는 이 플래그 비트를 조합하여 연결 요청(SYN), 응답 확인(ACK), 종료(FIN) 같은 제어 정보를 전달합니다.

3. 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
- 2-Way Handshake는 지연된 SYN 패킷 때문에 서버가 잘못된 연결을 수립하는 “Half-open connection” 문제가 발생합니다.
TCP는 이러한 오류를 방지하고 양쪽이 실제로 통신 가능한 상태인지 확인하기 위해 3-Way Handshake를 사용합니다.

4. 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
- TCP는 두 호스트가 동시에 SYN을 보내도 연결을 수립할 수 있습니다.
이를 Simultaneous Open이라고 하며, 양쪽이 서로 SYN을 보낸 뒤 SYN+ACK를 교환해 정상적인 3-Way Handshake가 완성됩니다.

5. SYN Flooding 에 대해 설명해 주세요.
- SYN Flooding은 TCP의 3-Way Handshake를 악용하는 대표적인 DDoS 공격입니다.
공격자가 SYN만 보내고 ACK를 보내지 않아 서버를 Half-open 상태로 유지시키며 자원을 고갈시키는 방식입니다.
서버는 SYN Cookie 같은 기술로 이를 방어합니다.

6. 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?
- 0-RTT는 과거의 세션 키를 재사용해 핸드셰이크와 데이터를 동시에 전송하는 방식입니다.
QUIC이나 TLS 1.3에서 지원하며, RTT를 기다리지 않고 바로 데이터를 보낼 수 있게 해줍니다.
단, 과거 세션을 기반으로 하기 때문에 첫 연결에서는 사용할 수 없습니다.

7. 4-Way Handshake에 대해 설명해 주세요.
- TCP의 연결 종료는 4-Way Handshake로 이루어집니다.
한쪽이 FIN을 보내면 상대는 ACK로 확인하고, 이후 상대도 FIN을 보내고 마지막 ACK를 받으며 종료됩니다.
양방향 연결을 독립적으로 종료하기 때문에 4단계가 필요합니다.

8. 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
- TCP 헤더의 Flags 필드를 보면 4-Way Handshake 패킷인지 알 수 있습니다.
종료 요청은 FIN, 확인은 ACK 플래그로 표시되므로 FIN 또는 FIN+ACK 조합의 패킷이 오간다면 연결 종료 과정임을 쉽게 구분할 수 있습니다.

9. 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
- TCP는 정상 종료는 4-Way Handshake지만, 긴급하게 종료할 때는 RST 플래그를 사용합니다.
RST는 연결을 즉시 비정상 종료시키며, 세션 상태를 정리할 시간 없이 빠르게 연결을 끊을 수 있습니다.

10. 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
- TCP는 상대 쪽 네트워크가 중간에 종료되면, ACK 재전송 실패나 Keep-Alive 실패로 이를 감지합니다.
응답이 오지 않으면 재전송 타이머가 만료되고, 결국 연결을 강제로 종료하게 됩니다.
경우에 따라 RST 패킷을 받고 즉시 종료하는 경우도 있습니다.

11. 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?
- TIME_WAIT은 TCP가 안정적인 연결 종료를 보장하기 위한 단계입니다.
첫째, 지연된 패킷이 새 연결에 영향을 주지 않도록 2MSL 동안 대기합니다.
둘째, 마지막 ACK이 손실될 경우 상대의 FIN 재전송에 응답할 수 있어야 하기 때문입니다.
따라서 Active close를 수행한 쪽은 반드시 TIME_WAIT 상태를 거칩니다.

12. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.
13. DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?
14. Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
15. URL, URI, URN은 어떤 차이가 있나요?
16. DNS에 대해 설명해 주세요.
17. DNS는 몇 계층 프로토콜인가요?
18. UDP와 TCP 중 어떤 것을 사용하나요?
19. DNS Recursive Query, Iterative Query가 무엇인가요?
20. DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
21. 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
22. DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
23. hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
