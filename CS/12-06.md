1. 3-Way Handshake에 대해 설명해 주세요.
- TCP는 신뢰성 있는 연결을 만들기 위해 3-Way Handshake를 이용합니다.
1단계에서 클라이언트가 SYN을 보내고, 2단계에서 서버는 SYN+ACK로 응답하며, 3단계에서 클라이언트가 ACK를 보내 연결이 수립됩니다.
이 과정을 통해 양쪽은 서로의 초기 시퀀스 번호를 공유하고, 데이터 전송 준비가 되었음을 확인합니다.

2. ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
- SYN, ACK 같은 정보는 TCP 헤더의 플래그 필드에서 비트 형태로 전달됩니다.
TCP는 이 플래그 비트를 조합하여 연결 요청(SYN), 응답 확인(ACK), 종료(FIN) 같은 제어 정보를 전달합니다.

3. 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
- 2-Way Handshake는 지연된 SYN 패킷 때문에 서버가 잘못된 연결을 수립하는 “Half-open connection” 문제가 발생합니다.
TCP는 이러한 오류를 방지하고 양쪽이 실제로 통신 가능한 상태인지 확인하기 위해 3-Way Handshake를 사용합니다.

4. 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
- TCP는 두 호스트가 동시에 SYN을 보내도 연결을 수립할 수 있습니다.
이를 Simultaneous Open이라고 하며, 양쪽이 서로 SYN을 보낸 뒤 SYN+ACK를 교환해 정상적인 3-Way Handshake가 완성됩니다.

5. SYN Flooding 에 대해 설명해 주세요.
- SYN Flooding은 TCP의 3-Way Handshake를 악용하는 대표적인 DDoS 공격입니다.
공격자가 SYN만 보내고 ACK를 보내지 않아 서버를 Half-open 상태로 유지시키며 자원을 고갈시키는 방식입니다.
서버는 SYN Cookie 같은 기술로 이를 방어합니다.

6. 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?
- 0-RTT는 과거의 세션 키를 재사용해 핸드셰이크와 데이터를 동시에 전송하는 방식입니다.
QUIC이나 TLS 1.3에서 지원하며, RTT를 기다리지 않고 바로 데이터를 보낼 수 있게 해줍니다.
단, 과거 세션을 기반으로 하기 때문에 첫 연결에서는 사용할 수 없습니다.

7. 4-Way Handshake에 대해 설명해 주세요.
- TCP의 연결 종료는 4-Way Handshake로 이루어집니다.
한쪽이 FIN을 보내면 상대는 ACK로 확인하고, 이후 상대도 FIN을 보내고 마지막 ACK를 받으며 종료됩니다.
양방향 연결을 독립적으로 종료하기 때문에 4단계가 필요합니다.

8. 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
- TCP 헤더의 Flags 필드를 보면 4-Way Handshake 패킷인지 알 수 있습니다.
종료 요청은 FIN, 확인은 ACK 플래그로 표시되므로 FIN 또는 FIN+ACK 조합의 패킷이 오간다면 연결 종료 과정임을 쉽게 구분할 수 있습니다.

9. 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
- TCP는 정상 종료는 4-Way Handshake지만, 긴급하게 종료할 때는 RST 플래그를 사용합니다.
RST는 연결을 즉시 비정상 종료시키며, 세션 상태를 정리할 시간 없이 빠르게 연결을 끊을 수 있습니다.

10. 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
- TCP는 상대 쪽 네트워크가 중간에 종료되면, ACK 재전송 실패나 Keep-Alive 실패로 이를 감지합니다.
응답이 오지 않으면 재전송 타이머가 만료되고, 결국 연결을 강제로 종료하게 됩니다.
경우에 따라 RST 패킷을 받고 즉시 종료하는 경우도 있습니다.

11. 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?
- TIME_WAIT은 TCP가 안정적인 연결 종료를 보장하기 위한 단계입니다.
첫째, 지연된 패킷이 새 연결에 영향을 주지 않도록 2MSL 동안 대기합니다.
둘째, 마지막 ACK이 손실될 경우 상대의 FIN 재전송에 응답할 수 있어야 하기 때문입니다.
따라서 Active close를 수행한 쪽은 반드시 TIME_WAIT 상태를 거칩니다.

12. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.
- 사용자가 브라우저에 www.github.com을 입력하면, 먼저 브라우저와 OS, hosts 파일에서 DNS 캐시를 확인하고, 없으면 설정된 DNS 서버에 질의해서 도메인에 대한 IP 주소를 얻습니다. IP를 알게 되면, 같은 네트워크 안에서 라우터의 MAC 주소를 찾기 위해 ARP를 수행하고, 그 다음 서버 IP와 443 포트로 TCP 3-way handshake를 통해 연결을 맺습니다. HTTPS 사이트이기 때문에 이어서 TLS handshake로 서버 인증서를 검증하고 세션 키를 협상한 뒤, 그 위에서 암호화된 HTTP 요청을 보냅니다. 서버나 로드밸런서는 이 요청을 실제 웹/애플리케이션 서버로 전달해서 응답 HTML을 만들고, 브라우저는 HTML과 추가 리소스들(CSS/JS/이미지 등)을 받아 렌더링해서 화면에 보여줍니다.

13. DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?
- DNS 쿼리로 얻은 IP는 보통 그 도메인이 제공하는 서비스의 진입점을 가리킵니다. 작은 서비스라면 실제 웹 서버의 IP일 수 있고, 규모가 있는 서비스라면 L4/L7 로드밸런서나 CDN 엣지 같은 프런트 엔드 서버의 IP인 경우가 많습니다. 즉, ‘이 도메인으로 접속하고 싶다’고 했을 때, 트래픽이 처음 도착하는 엔드포인트를 DNS가 알려준다고 보면 됩니다.

14. Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
- 웹 서버는 주로 정적 리소스를 클라이언트에 전달하고, 프록시나 로드밸런싱, SSL 종료 같은 역할을 담당합니다. 대표적으로 Nginx나 Apache가 있고요. 반면 Web Application Server, 즉 WAS는 비즈니스 로직을 수행해서 동적인 컨텐츠를 만들어내는 서버입니다. Java 기준으로는 Tomcat, JBoss 같은 서버가 여기에 해당하고, DB 연동, 세션 관리 등을 처리합니다. 보통 구조는 클라이언트 요청이 웹 서버를 거쳐 WAS로 전달되고, 웹 서버는 정적 파일을 직접 서빙해서 전체 성능과 보안을 개선하는 방식으로 구성합니다.

15. URL, URI, URN은 어떤 차이가 있나요?
- URI는 어떤 리소스를 식별하기 위한 문자열 전체를 말하고, 그 안에 URL과 URN이 포함됩니다. URL은 https://example.com/path 처럼 리소스의 위치와 접근 방법을 알려주는 ‘주소’에 해당하고, URN은 urn:isbn:...처럼 위치와 상관없이 이름으로만 리소스를 식별하는 방식입니다. 그래서 보통 우리가 웹에서 쓰는 주소들은 대부분 URL이면서 URI라고 이해하시면 됩니다.

16. DNS에 대해 설명해 주세요.
- DNS는 사람이 사용하는 도메인 이름을 실제 통신에 필요한 IP 주소로 변환하는 시스템입니다. 루트–TLD–Authoritative 서버로 구성된 계층적 구조를 가지고 있고, A/AAAA/CNAME 같은 여러 레코드를 제공하며, 캐싱 기반으로 빠르고 안정적으로 작동합니다.

17. DNS는 몇 계층 프로토콜인가요?
- DNS는 이름을 IP로 변환하는 기능을 제공하는 Application Layer 프로토콜입니다.

18. UDP와 TCP 중 어떤 것을 사용하나요?
- 일반 조회는 UDP 53 포트를 사용해 빠르게 처리하고, 응답이 크거나 서버 간 Zone Transfer처럼 대량 데이터를 주고받을 때는 TCP 53 포트를 사용합니다.

19. DNS Recursive Query, Iterative Query가 무엇인가요?
- Recursive Query는 DNS Resolver가 클라이언트를 대신해서 Root–TLD–Authoritative 서버까지 모두 조회해 최종 IP를 찾아오는 방식이고, Iterative Query는 각 DNS 서버가 ‘내가 아는 가장 가까운 정보’만 반환하고, 클라이언트가 직접 다음 DNS 서버에 계속 질의하는 방식입니다. 실제 사용자는 Recursive Resolver를 사용하지만, Root/TLD 같은 상위 DNS 서버들은 Iterative 방식으로 동작합니다.

20. DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
- DNS는 UDP 기반이라 손실이 발생할 수 있는데, 이런 경우 클라이언트나 로컬 DNS Resolver가 재전송을 수행하고, 응답이 없으면 보조 DNS 서버로 요청을 넘겨 Failover합니다. 또한 UDP 응답이 지속적으로 실패하면 TCP로 자동 전환하여 안정성을 확보합니다.

21. 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
- DNS 캐시는 TTL 기반으로 자동 갱신되며, 필요 시 클라이언트 측에서 flush하거나 DNS 서버 측에서 강제로 캐시를 비울 수 있습니다. 서버 IP를 변경하는 경우에는 TTL을 미리 줄여서 장애를 방지하는 방식으로 운영합니다.

22. DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
- 레코드는 IPv4 주소, AAAA 레코드는 IPv6 주소를 매핑하는 레코드입니다. CNAME은 도메인 이름을 다른 도메인 이름에 연결하는 별칭 레코드로, 결국 최종적으로는 A나 AAAA 같은 IP 레코드로 이어져야 합니다.

23. hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
- hosts 파일은 로컬에서 도메인을 특정 IP에 강제 매핑하는 파일이며, DNS보다 우선순위가 높습니다. 따라서 hosts에 기록이 있으면 DNS를 조회하지 않고 바로 그 IP로 접속합니다. 개발 환경 구성이나 테스트 시 특정 서버로 강제 연결하는 데 사용됩니다.

24. SOP 정책에 대해 설명해 주세요.
- SOP는 브라우저가 서로 다른 Origin 간의 리소스 접근을 제한하는 보안 정책입니다. 프로토콜·도메인·포트 중 하나라도 다르면 다른 Origin으로 간주되고, JS에서 응답이나 쿠키·LocalStorage 등을 읽지 못하게 막습니다. 이는 XSS/CSRF 같은 공격을 방지하기 위한 핵심 정책입니다
25. CORS 정책이 무엇인가요?
- CORS는 SOP 제한을 우회할 수 있도록 서버가 특정 Origin을 명시적으로 허용해주는 메커니즘입니다. 서버가 ‘Access-Control-Allow-Origin’ 등과 같은 헤더로 허용을 선언하면 브라우저는 Cross-Origin 요청을 허용하게 됩니다.

26. Preflight에 대해 설명해 주세요.
- 브라우저가 Cross-Origin 요청을 보내기 전에 서버가 이 요청을 허용하는지 확인하기 위해 보내는 OPTIONS 요청이 Preflight입니다. GET/POST/HEAD가 아닌 메서드, 커스텀 헤더, 인증 정보 등이 포함된 경우 Preflight 요청이 발생합니다.

27. Stateless와 Connectionless에 대해 설명해 주세요.
- Stateless는 서버가 이전 요청의 상태를 저장하지 않는 설계 방식이며, HTTP와 REST API의 핵심 원칙입니다. Connectionless는 네트워크 연결을 유지하지 않고 패킷 단위로 독립적으로 통신하는 방식으로, UDP가 대표적입니다. 하나는 애플리케이션 설계 철학이고, 다른 하나는 네트워크 전송 방식이라는 점에서 차이가 있습니다.

28. 왜 HTTP는 Stateless 구조를 채택하고 있을까요?
- HTTP가 Stateless를 채택한 이유는 서버가 상태를 보관하지 않음으로써 확장성, 장애 복구, 로드밸런싱에 매우 유리하기 때문입니다. 초기 웹 구조가 단순 문서 요청 기반이었던 점도 Stateless를 선택한 배경이고, 지금까지도 대규모 트래픽을 효율적으로 처리하는 데 적합한 구조입니다.

29. Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?
- Connectionless 방식이 신뢰성은 떨어지지만, 애플리케이션 레벨에서 재전송·순서 보장 같은 보완 기능을 직접 구현하거나, 필요 시 TCP로 fallback하는 방식으로 해결합니다. 지연이 낮아야 하는 DNS, 게임, 스트리밍은 Connectionless 덕분에 더 높은 성능을 얻습니다.

30. TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?
- TCP Keep-Alive는 TCP 연결이 살아있는지 확인하기 위해 OS 레벨에서 주기적으로 헬스체크 패킷을 보내는 기능입니다. 반면 HTTP Keep-Alive는 하나의 TCP 연결을 여러 HTTP 요청에 재사용하기 위한 애플리케이션 레벨 최적화입니다. 하나는 네트워크 상태 확인, 다른 하나는 성능 개선을 목표로 한다는 점에서 큰 차이가 있습니다.

31. 라우터 내의 포워딩 과정에 대해 설명해 주세요.
32. 라우팅과 포워딩의 차이는 무엇인가요?
33. 라우팅 알고리즘에 대해 설명해 주세요.
34. 포워딩 테이블의 구조에 대해 설명해 주세요.
35. 로드밸런서가 무엇인가요?
36. L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
37. 로드밸런서 알고리즘에 대해 설명해 주세요.
38. 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?
39. 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
