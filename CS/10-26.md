1. 단기 중기 장기 스케쥴려란?
- 운영체제에서 스케쥴려는 프로세스에게 CPU를 어떤 방식으로 할당할지 결정하는 역할
- 장기
  +  실행 대기중인 작업중 어떤 것을 메모리에 로드하여 Ready Queue에 넣을지 정함
- 중기
  + 장기 스케쥴러가 메모리에 프로세스를 올린뒤 메모리가 부족해지면 swap out, swap in을 통해 이를 조절하는 역할
- 단기
  + Ready Queue에 있는 프로세스들중 누가 당장 CPU를 사용할지 정함

2.현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?
- 단기 스케줄러를 중심으로 동작하고 중기 스케줄러는 메모리 부족 시 Swap을 위한 형태로 일부 존재하고. 장기 스케줄러는 거의 사용되지 않습니다.

3.프로세스의 스케쥴링 상태에 대해 설명해 주세요.
- 프로세스는 보통 NEW(생성) -> Ready(실행대기 CPU 배정을 기다림) -> Running(Cpu를 점유하여 실행 중) -> Blocked(I/O 이벤트 대기) -> Teminated(종료) 상태를 거치고 메모리가 부족하면 Suspended Ready(메모리 부족 등으로 Ready지만 메모리 밖) 또는 Suspended Blocked(Blocked 상태 + 메모리 밖) 상태가 포함됩니다.

4.preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?
- 상태 자체는 동일하나, Non-preemptive에서는 Running -> Ready전환이 없어 CPU를 자발적으로 반납해야 한다.
  
5.Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?
- 메모리가 부족할 경우 중기 스케줄러에 의해서 process는 suspended Ready 또는 suspended Block으로 상태가 변환한다.

6. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?
- 현재 실행중인 프로세스나/스레드의 작업을 멈춰두고 다음 실행할 프로세스와/스레드를 실행한 준비로 상태를 가져오는 역할을 합니다.
- 단계별 동작
  + 인터럽트 또는 스케줄링 이벤트 발생
  + 현재 실행 중인 cpu 레지스터 값 저장
  + 프로세스 상태 변경
  + 스케줄러가 다음 프로세스 선택
  + 선택된 프로세스의 컨텍스 불러오기
  + CPU 실행 재개 

7. 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?
- 프로세스는 각각의 독립된 주소 공간을 가지기 때문에 컨텍스트 스위칭 시 페이지 테이블 교체와 TLB flush가 필요해 오버헤드가 크다.
- 스레드는 같은 주소 공간을 공유하므로 레지스터와 스택만 교체하면 되어 상대적으로 비용이 적다.

8. 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?
- 컨텍스트 스위칭이 일어나면, CPU는 현재 실행 중인 프로세스의 레지스터 값, 프로그램 카운터, 스택 포인터, CPU 플래그 등을 프로세스마다 존재하는 커널 스택의 top에 Context Frame 형태로 저장합니다. 그리고 이 정보는 PCB와 연결되며 다음에 해당 프로세스가 다시 실행될 떄 이값들을 복원합니다.

9. 컨텍스트 스위칭은 언제 일어날까요?
- 컨텍스트 스위칭은 현재 실행중인 프로세스를 중단하고 다른 프로세스를 실행해야 할 때 발생합니다. 구처젝으로는 CPU 스케줄러에 의해 선점될 떄, 프로세스가 I/O 요청 등으로 block될 때, 프로세스가 자발적으로 CPU를 양보할 때, 인터럽트가 발생해서 커널이 실행 흐름을 바꿀 때

10. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?
- FCFS, SJF, SRTF, Priority Scheduling, Round Robin, Multilevel Queue, Multilevel Feedback Queue, 그리고 현대 시스템에서는 Linux CFS 같은 Fair Scheduler를 사용합니다.

11. RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.
- Time Slice의 크기에 따라 trade-off가 달라지며, Time Slice가 크면 오버헤드는 줄지만 반응성이 떨어지고, Time Slice가 작으면 반응성은 좋아지지만 컨텍스트 스위칭 오버헤드가 커집니다. 따라서 시스템 성격에 맞게 적절한 값이 필요합니다.

12. 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?
- 싱글 스레드 CPU 환경에서 상시 실행되어야 하는 프로세스가 존재한다면
고정 우선순위 기반 선점형 스케줄링(Fixed-Priority Preemptive Scheduling) 을 사용하는 것이 적합합니다.
해당 프로세스에 가장 높은 우선순위를 부여하여,
다른 작업이 실행 중이더라도 즉시 CPU를 선점할 수 있도록 해야 합니다.
FCFS, RR, SJF 같은 범용 알고리즘은
해당 프로세스가 다른 작업에 의해 지연되거나 타임슬라이스 단위로 중단될 수 있기 때문에 적합하지 않습니다.
실시간 시스템의 경우 Rate-Monotonic이나 EDF 같은 알고리즘도 적용할 수 있습니다.

13. 동시성과 병렬성의 차이에 대해 설명해 주세요.
- 동시성은, 여러 일을 번갈아 빠르게 처리하는 것이고, 병렬성은 여러 일을 동시에 처리하는 것입니다.

14. 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?
- MLFQ는 여러 레벨의 큐를 두고, 프로세스를 CPU 사용 패턴에 따라 위아래로 이동시키는 방식입니다.
짧게 실행되는 인터랙티브 작업은 높은 우선순위에서 빠르게 처리하고,
CPU를 오래 쓰는 작업은 점차 낮은 큐로 내려서 처리합니다.
이를 통해 SJF처럼 짧은 작업에 유리하면서도,
우선순위 스케줄링의 기아 문제도 해결할 수 있습니다.

15. FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?
16. 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?
17. 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?
18. Deadlock에 대해 설명해주세요.
- 두 개 이상의 프로세스나 스레드가 서로가 보유한 자원을 기다리며 영원히 진행되지 않는 상태를 말합니다.
19. Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.
- 상호배제 : 자원은 한 번에 하나의 프로세스만 사용할 수 있어야 함
- 점유대기 : 프로세스가 이미 자원을 보유한 상태에서 추가 자원을 요청하며 기다리는 상태
- 비선점 : 자원을 강제로 빼앗을 수 없음, 프로세스가 스스로 놓기 전까지는 다른 프로세스가 사용할 수 없음
- 순환대기 : 자원을 대기하는 프로세스들이 원형(사이클)을 이루며 서로의 자원을 기다리는 구조
20. 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?
- 순환 대기 고리가 형성되지 않으면 언젠가 자원이 반환되기 때문에 영구적 교착 상태가 아니라 단순 자원 대기일 뿐이기 때문입니다.
21. 어떤 방식으로 예방할 수 있을까요?
- 공유 가능한 자원으로 설계하여 상호 배제 제거
- 자원을 한 번에 요청하게 하거나 요청 실패 시 반납하여 점유 대기 제거
- 자원을 강제로 빼앗을 수 있도록 하여 비선점 제거
- 자원 획득 순서를 정해 순환 대기 제거
  
22. 왜 현대 OS는 Deadlock을 처리하지 않을까요?
- 현대 OS는 Deadlock을 완벽하게 예방하거나 회피하는 대신,
발생 시 일부 프로세스만 종료하거나 timeout으로 처리합니다.
그 이유는 Deadlock 관리 비용이 매우 크고,
대부분의 Deadlock이 애플리케이션 레벨에서 처리되기 때문입니다.
23. Wait Free와 Lock Free를 비교해 주세요.
- Wait-Free는 모든 스레드가 유한 시간 내에 반드시 작업을 완료하는 것을 보장하고,
Lock-Free는 최소한 한 스레드는 계속 진행할 수 있도록 보장합니다.
Wait-Free는 기아가 없고 가장 강력한 진행 보장을 제공하지만 구현이 어렵고 비용이 큽니다.
Lock-Free는 실무에서 많이 쓰이며, CAS 기반으로 재시도 방식으로 동작합니다.
