1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.
- Key는 테이블의 행을 식별하거나 무결성을 보장하기 위한 컬럼의 집합입니다.
슈퍼키는 유일성을 만족하는 모든 키 집합이고,
그중 최소성을 만족하는 것이 후보키입니다.
후보키 중 하나를 선택한 것이 기본키이며,
기본키로 선택되지 않은 후보키는 대체키가 됩니다.
외래키는 다른 테이블의 기본키를 참조하여 테이블 간 관계를 표현합니다.

2. 기본키는 수정이 가능한가요?
- 기본키는 기술적으로 수정이 가능하지만,
다른 테이블에서 참조될 가능성이 높기 때문에
설계 관점에서는 수정하지 않는 것이 원칙입니다.
그래서 실무에서는 의미 없는 surrogate key를 기본키로 사용합니다.

3. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
- MySQL은 SQL 표준에 따라 기본키 없이도 테이블 생성을 허용합니다.
InnoDB에서는 기본키가 없을 경우 내부적으로 hidden row id를 생성해
클러스터드 인덱스를 구성하기 때문에 동작이 가능합니다.
다만 성능과 무결성 측면에서 기본키를 명시하는 것이 권장됩니다.

4. 외래키 값은 NULL이 들어올 수 있나요?
- 외래키 컬럼에는 NULL 값이 들어올 수 있습니다.
이는 해당 레코드가 아직 다른 테이블과 관계를 맺지 않았다는 의미이며,
이 경우 참조 무결성 검사는 수행되지 않습니다.
관계가 필수라면 NOT NULL 제약을 함께 사용합니다.

5. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
- UNIQUE 키가 붙은 컬럼은 내부적으로 유니크 인덱스가 생성됩니다.
따라서 해당 컬럼을 조건으로 사용하는 조회 쿼리는
풀 스캔이 아닌 인덱스 탐색으로 성능이 향상됩니다.
다만 INSERT나 UPDATE 시에는 중복 검사로 인해 약간의 쓰기 비용이 발생합니다.

6. RDB와 NoSQL의 차이에 대해 설명해 주세요.
- RDB는 정형 스키마와 관계를 기반으로 ACID 트랜잭션을 보장하는 데이터베이스이고,
NoSQL은 스키마가 유연하며 수평 확장과 대량 데이터 처리를 중점으로 설계된 데이터베이스입니다.
RDB는 데이터 정합성과 복잡한 조인이 강점이고,
NoSQL은 확장성과 성능, 가용성을 우선시합니다.

7. NoSQL의 강점과, 약점이 무엇인가요?
- NoSQL의 강점은 수평 확장성과 고성능, 그리고 유연한 스키마입니다.
반면 트랜잭션과 강한 정합성이 필요한 경우에는 한계가 있으며,
복잡한 조인이나 정형 데이터 관리에는 RDB보다 불리합니다.

8. RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 수 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
- RDB는 트랜잭션, 조인, 정규화, 무결성 제약 등으로 인해
동시성이 높아질수록 Lock 경합과 I/O 비용이 증가할 수 있습니다.
이러한 특성 때문에 단순 조회나 대량 트래픽 환경에서는
NoSQL보다 부하가 더 크게 나타날 수 있습니다.

9. NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

10. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.
- 트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위이며,
ACID 원칙을 통해 데이터의 신뢰성을 보장합니다.
Atomicity는 전부 수행되거나 전부 실패함을,
Consistency는 제약 조건을 만족함을,
Isolation은 동시 실행 간 간섭을 막음을,
Durability는 커밋된 데이터가 장애 이후에도 유지됨을 의미합니다.

11. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
- DBMS는 Write-Ahead Logging 방식을 통해 Durability를 보장합니다.
트랜잭션이 커밋되기 전에 변경 내용을 로그 파일에 먼저 기록하고,
장애 발생 시 이 로그를 기반으로 복구를 수행합니다.
따라서 커밋이 완료된 데이터는 시스템 장애 이후에도 유지됩니다.

12. 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
- 트랜잭션은 여러 DB 작업이 하나의 논리적 단위일 때 사용합니다.
중간 실패 시 정합성이 깨질 수 있는 경우에 반드시 필요합니다.

13. 읽기에는 트랜잭션을 걸지 않아도 될까요?
- 단순 조회의 경우 트랜잭션 없이도 가능하지만,
조회 결과를 기반으로 이후 로직이 결정되거나
쓰기와 결합되는 경우에는 트랜잭션이 필요합니다.
특히 동시성 환경에서는 읽기에도 트랜잭션이
정합성 보장을 위해 중요합니다.

14. 트랜잭션 격리 레벨에 대해 설명해 주세요.
- 트랜잭션 격리 레벨은 동시에 실행되는 트랜잭션 간의 간섭을 얼마나 허용할지를 정의한 기준입니다.
READ UNCOMMITTED부터 SERIALIZABLE까지 4단계가 있으며,
격리 수준이 높아질수록 정합성은 강화되지만 동시성은 감소합니다.

15. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
- 모든 DBMS가 SQL 표준의 4단계 격리 레벨을 동일하게 구현하지는 않습니다.
이는 내부 구현 방식과 성능 트레이드오프 때문이며,
특히 SERIALIZABLE은 구현 비용과 성능 저하로 인해 제한적으로 제공됩니다.
따라서 격리 레벨의 실제 동작은 DBMS마다 다를 수 있습니다.

16. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
- InnoDB에서 Undo Log는 트랜잭션 이전 상태를 저장하여
롤백과 MVCC 기반 읽기를 지원합니다.
Redo Log는 변경 이후의 내용을 기록해
시스템 장애 발생 시 커밋된 트랜잭션을 복구하는 데 사용됩니다.
두 로그는 각각 Isolation과 Durability를 담당합니다.

17. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
- 스토리지 엔진은 실제로 데이터를 디스크에 저장하고
인덱스, 트랜잭션, 락, 복구 같은 저수준 동작을 담당하는 MySQL의 핵심 구성 요소입니다.
MySQL은 엔진 플러그인 구조를 가지며,
InnoDB는 트랜잭션과 MVCC를 지원하는 기본 스토리지 엔진입니다.
