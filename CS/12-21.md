1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.
- Key는 테이블의 행을 식별하거나 무결성을 보장하기 위한 컬럼의 집합입니다.
슈퍼키는 유일성을 만족하는 모든 키 집합이고,
그중 최소성을 만족하는 것이 후보키입니다.
후보키 중 하나를 선택한 것이 기본키이며,
기본키로 선택되지 않은 후보키는 대체키가 됩니다.
외래키는 다른 테이블의 기본키를 참조하여 테이블 간 관계를 표현합니다.

2. 기본키는 수정이 가능한가요?
- 기본키는 기술적으로 수정이 가능하지만,
다른 테이블에서 참조될 가능성이 높기 때문에
설계 관점에서는 수정하지 않는 것이 원칙입니다.
그래서 실무에서는 의미 없는 surrogate key를 기본키로 사용합니다.

3. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
- MySQL은 SQL 표준에 따라 기본키 없이도 테이블 생성을 허용합니다.
InnoDB에서는 기본키가 없을 경우 내부적으로 hidden row id를 생성해
클러스터드 인덱스를 구성하기 때문에 동작이 가능합니다.
다만 성능과 무결성 측면에서 기본키를 명시하는 것이 권장됩니다.

4. 외래키 값은 NULL이 들어올 수 있나요?
- 외래키 컬럼에는 NULL 값이 들어올 수 있습니다.
이는 해당 레코드가 아직 다른 테이블과 관계를 맺지 않았다는 의미이며,
이 경우 참조 무결성 검사는 수행되지 않습니다.
관계가 필수라면 NOT NULL 제약을 함께 사용합니다.

5. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
- UNIQUE 키가 붙은 컬럼은 내부적으로 유니크 인덱스가 생성됩니다.
따라서 해당 컬럼을 조건으로 사용하는 조회 쿼리는
풀 스캔이 아닌 인덱스 탐색으로 성능이 향상됩니다.
다만 INSERT나 UPDATE 시에는 중복 검사로 인해 약간의 쓰기 비용이 발생합니다.

6. RDB와 NoSQL의 차이에 대해 설명해 주세요.
- RDB는 정형 스키마와 관계를 기반으로 ACID 트랜잭션을 보장하는 데이터베이스이고,
NoSQL은 스키마가 유연하며 수평 확장과 대량 데이터 처리를 중점으로 설계된 데이터베이스입니다.
RDB는 데이터 정합성과 복잡한 조인이 강점이고,
NoSQL은 확장성과 성능, 가용성을 우선시합니다.

7. NoSQL의 강점과, 약점이 무엇인가요?
- NoSQL의 강점은 수평 확장성과 고성능, 그리고 유연한 스키마입니다.
반면 트랜잭션과 강한 정합성이 필요한 경우에는 한계가 있으며,
복잡한 조인이나 정형 데이터 관리에는 RDB보다 불리합니다.

8. RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 수 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
- RDB는 트랜잭션, 조인, 정규화, 무결성 제약 등으로 인해
동시성이 높아질수록 Lock 경합과 I/O 비용이 증가할 수 있습니다.
이러한 특성 때문에 단순 조회나 대량 트래픽 환경에서는
NoSQL보다 부하가 더 크게 나타날 수 있습니다.

9. NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

10. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.
- 트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위이며,
ACID 원칙을 통해 데이터의 신뢰성을 보장합니다.
Atomicity는 전부 수행되거나 전부 실패함을,
Consistency는 제약 조건을 만족함을,
Isolation은 동시 실행 간 간섭을 막음을,
Durability는 커밋된 데이터가 장애 이후에도 유지됨을 의미합니다.

11. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
- DBMS는 Write-Ahead Logging 방식을 통해 Durability를 보장합니다.
트랜잭션이 커밋되기 전에 변경 내용을 로그 파일에 먼저 기록하고,
장애 발생 시 이 로그를 기반으로 복구를 수행합니다.
따라서 커밋이 완료된 데이터는 시스템 장애 이후에도 유지됩니다.

12. 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
- 트랜잭션은 여러 DB 작업이 하나의 논리적 단위일 때 사용합니다.
중간 실패 시 정합성이 깨질 수 있는 경우에 반드시 필요합니다.

13. 읽기에는 트랜잭션을 걸지 않아도 될까요?
- 단순 조회의 경우 트랜잭션 없이도 가능하지만,
조회 결과를 기반으로 이후 로직이 결정되거나
쓰기와 결합되는 경우에는 트랜잭션이 필요합니다.
특히 동시성 환경에서는 읽기에도 트랜잭션이
정합성 보장을 위해 중요합니다.

14. 트랜잭션 격리 레벨에 대해 설명해 주세요.
- 트랜잭션 격리 레벨은 동시에 실행되는 트랜잭션 간의 간섭을 얼마나 허용할지를 정의한 기준입니다.
READ UNCOMMITTED부터 SERIALIZABLE까지 4단계가 있으며,
격리 수준이 높아질수록 정합성은 강화되지만 동시성은 감소합니다.

15. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
- 모든 DBMS가 SQL 표준의 4단계 격리 레벨을 동일하게 구현하지는 않습니다.
이는 내부 구현 방식과 성능 트레이드오프 때문이며,
특히 SERIALIZABLE은 구현 비용과 성능 저하로 인해 제한적으로 제공됩니다.
따라서 격리 레벨의 실제 동작은 DBMS마다 다를 수 있습니다.

16. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
- InnoDB에서 Undo Log는 트랜잭션 이전 상태를 저장하여
롤백과 MVCC 기반 읽기를 지원합니다.
Redo Log는 변경 이후의 내용을 기록해
시스템 장애 발생 시 커밋된 트랜잭션을 복구하는 데 사용됩니다.
두 로그는 각각 Isolation과 Durability를 담당합니다.

17. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
- 스토리지 엔진은 실제로 데이터를 디스크에 저장하고
인덱스, 트랜잭션, 락, 복구 같은 저수준 동작을 담당하는 MySQL의 핵심 구성 요소입니다.
MySQL은 엔진 플러그인 구조를 가지며,
InnoDB는 트랜잭션과 MVCC를 지원하는 기본 스토리지 엔진입니다.

18. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.
- 인덱스는 테이블의 특정 컬럼을 정렬된 자료구조로 관리해 탐색 성능을 높이는 구조이며,
조건 조회나 조인처럼 읽기 비중이 높고 선택도가 높은 경우에 사용합니다.

19. 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
- 인덱스는 데이터 변경 시마다 함께 갱신되기 때문에,
수정이 잦은 테이블에서는 쓰기 성능 저하와 락 경합을 유발할 수 있습니다.

20. 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
- 수정이 잦다는 이유만으로 인덱스를 배제하지는 않으며,
조회 빈도와 서비스 영향도를 기준으로 비용 대비 이득을 판단합니다.

21. ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
- 인덱스가 없으면 ORDER BY와 GROUP BY는 정렬이나 임시 테이블을 사용하지만,
인덱스가 있으면 이미 정렬된 순서로 스캔하면서 연산을 처리할 수 있어 비용이 크게 줄어듭니다.

22. 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
- 기본키 자체가 인덱스는 아니고, 기본키 제약을 구현하기 위해 유니크 인덱스가 생성된다고 보는 것이 정확합니다.

23. 그렇다면 외래키는요?
- 외래키도 인덱스가 아니라 무결성 제약이며,
성능을 위해 외래키 컬럼에 인덱스를 별도로 생성하는 것이 일반적입니다.

24. 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
- 일반 인덱스는 물리적 저장 순서에 영향을 주지 않으며,
데이터는 페이지 단위로 DBMS 내부 정책에 따라 저장됩니다.
단, 클러스터드 인덱스는 예외입니다.

25. 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
- NoSQL도 인덱스를 가지지만,
RDB처럼 복잡한 조인과 트랜잭션 최적화보다는 단순하고 빠른 조회에 초점을 둡니다.

26. (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
- (A, B) 복합 인덱스는 A부터 조건이 있어야 사용 가능하며,
A 없이 B만 사용하는 경우 일반적으로 인덱스를 타지 않습니다.

27. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.
-RDBMS는 정합성을 중시해 주로 Primary-Replica 구조를 사용하고,
NoSQL은 분산 환경을 전제로 클러스터링과 레플리케이션을 기본 제공하는 경우가 많습니다.

28. 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
- 분산 환경에서는 2PC로 강한 정합성을 보장할 수 있지만 비용이 크고,
실무에서는 Saga 같은 보상 기반 트랜잭션을 더 많이 사용합니다.

29. 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
- 복제 지연 구간에서는 읽기를 Primary로 유도하거나,
Semi-sync 복제나 버전 기반 검증으로 정합성을 보완할 수 있습니다.

30. 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
- Deadlock은 서로가 가진 락을 기다리는 상황이며,
DB는 이를 감지해 한 트랜잭션을 롤백하거나, 락 순서 통일로 예방합니다.

31. 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
- 초기에는 운영 복잡도가 낮은 레플리케이션을 사용하고,
쓰기 병목이 발생하면 샤딩을 단계적으로 도입하는 선택을 할 것 같습니다.

32. 정규화가 무엇인가요?
- 정규화는 데이터 중복을 제거하고, 각 데이터가 하나의 의미만 가지도록 테이블을 분리하는 설계 과정입니다.
이를 통해 삽입, 수정, 삭제 시 발생하는 이상 현상을 방지하고, 데이터 무결성과 일관성을 높이는 것이 목적입니다.
성능보다는 데이터 구조의 안정성과 유지보수성을 우선하는 개념입니다.

33. 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
- 정규화가 안 되면 삽입, 수정, 삭제 시 의도하지 않은 데이터 손실이나 불일치가 발생합니다.
이는 하나의 테이블에 여러 의미의 데이터가 섞여 있기 때문입니다.

34. 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
- 정규화는 컬럼이 누구에게 종속되는지를 기준으로 테이블을 분리하는 과정이며,
1정규형은 반복 제거, 2정규형은 부분 종속 제거, 3정규형은 이행 종속 제거를 목표로 합니다

35. 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.
- 정규화는 데이터 무결성을 높이지만 조인 비용이 증가할 수 있습니다.
따라서 조회 성능이 중요한 구간에서는, 데이터 변경이 적다는 전제하에 부분적인 역정규화를 선택하기도 합니다.
실무에서는 정규화된 모델을 기준으로, 성능 병목이 확인된 영역에만 역정규화를 적용합니다.

36. View가 무엇이고, 언제 사용할 수 있나요?
- View는 하나 이상의 테이블에 대한 SELECT 결과를 논리적으로 저장한 객체로,
실제 데이터를 저장하지 않고 원본 테이블을 참조합니다.
주로 복잡한 조회 로직을 캡슐화하거나, 보안상 특정 컬럼만 노출하거나,
읽기 전용 조회 모델을 만들 때 사용합니다.

37. 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?
- View는 기본적으로 읽기 전용이며,
단일 테이블 기반의 단순한 View에 한해서만 수정이 원본 테이블에 반영됩니다.
실무에서는 View를 수정 용도로 사용하는 것은 지양합니다.

38. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.
- JOIN은 정규화로 분리된 테이블들을 공통 컬럼을 기준으로 결합하는 연산입니다.
INNER JOIN은 교집합, OUTER JOIN은 기준 테이블을 유지하는 방식이며,
실무에서는 대부분 INNER와 LEFT JOIN을 사용합니다.

39. 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
- JOIN은 비용이 큰 연산이기 때문에, DB는 Nested Loop, Hash Join, Sort Merge Join 같은 다양한 알고리즘을 사용합니다.
옵티마이저는 테이블 크기와 인덱스 여부를 기준으로 가장 비용이 낮은 방식을 선택하며,
실무에서 JOIN 성능 문제는 대부분 인덱스 설계나 조인 순서 문제에서 발생합니다.

40. 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
-JOIN 구현 방식은 SQL 문법이 아니라 실행 계획을 통해 확인합니다.
EXPLAIN이나 EXPLAIN ANALYZE를 사용하면 DB가 어떤 JOIN 알고리즘을 선택했는지,
어떤 인덱스를 사용했는지까지 확인할 수 있습니다.
동일한 쿼리라도 데이터 분포나 통계에 따라 실행 계획은 달라질 수 있습니다.

41. 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
- JOIN 성능은 조인 조건 컬럼에 인덱스가 있는지에 크게 좌우됩니다.
특히 Nested Loop Join에서는 인덱스가 없으면 성능이 급격히 나빠지며,
실무에서 JOIN 성능 문제의 대부분은 인덱스 설계 문제로 귀결됩니다.

42. 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.
- 3중 JOIN부터는 DB가 어떤 테이블부터 JOIN할지 조인 순서를 결정해야 합니다.
DB는 항상 두 테이블씩 JOIN하며, 중간 결과 집합의 크기가 전체 성능에 큰 영향을 미칩니다.
따라서 조인 순서와 각 단계의 인덱스 유무가 성능을 좌우하며,
실무에서는 통계 정보가 부정확할 경우 옵티마이저가 비효율적인 순서를 선택하기도 합니다.
